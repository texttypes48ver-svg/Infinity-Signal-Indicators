// =====================================================================
// Infinity Signal
// Indicator: MA4 Alignment with Forward Projection
// Version: v1.0.0
// Last Updated: 2026-02-01
// License: See LICENSE file in this repository (or repository root)
// =====================================================================

//@version=6
indicator(
    "MA4 Alignment with Forward Projection",
    overlay=true,
    scale=scale.right,
    max_lines_count=500,
    max_labels_count=500,
    max_bars_back=5000
)

//====================================================
// INPUTS
//====================================================
maLen = input.int(4, "MA Length", minval=1)
src   = input.source(close, "Source")

liveNowColor  = input.color(color.blue, "Live 4MA Color")
livePrevColor = input.color(color.red,  "Live 4MA[1] Color")

startBarsBack = input.int(220, "Pattern Start (bars back)", minval=1)
endBarsBack   = input.int(180, "Pattern End (bars back)",   minval=1)
shiftForward  = input.int(50,  "Shift Pattern Forward (bars)", minval=0)

useDeltaAnchor = input.bool(true, "Delta-anchor projection")
showProj       = input.bool(true, "Show Projection")

projNowColor   = input.color(color.aqua,   "Projected 4MA Color")
projPrevColor  = input.color(color.orange, "Projected 4MA[1] Color")

//====================================================
// Projected Cross Vertical Lines
//====================================================
showProjCrossVLines = input.bool(true, "Mark projected crosses (Vertical Lines)")
vlineBullColor      = input.color(color.lime, "Bull Cross VLine Color")
vlineBearColor      = input.color(color.red,  "Bear Cross VLine Color")
vlineWidth          = input.int(2, "VLine Width", minval=1, maxval=4)
vlineStyleInput     = input.string("Dotted", "VLine Style", options=["Solid","Dotted","Dashed"])

// Height behavior: use deviation width, fallback to ATR
sd4ForHeight         = input.float(2.618, "VLine Height uses Band4 Mult (× StDev)", step=0.001, minval=0.0)
vlineHeightMult      = input.float(1.0, "VLine Height = (Band4 width) ×", minval=0.1, step=0.1)
vlineAtrFallbackMult = input.float(0.8, "Fallback Height = ATR ×", minval=0.1, step=0.1)

//====================================================
// Alerts (optional) — uses projected deviation envelopes (Band3/Band4)
//====================================================
enableAlerts = input.bool(true, "Enable Alerts")
useWicks     = input.bool(true, "Use Wicks")
alertBand3   = input.bool(true, "Alert Band 3 (Stretch)")
alertBand4   = input.bool(true, "Alert Band 4 (Invalidation)")

sd3AlertMult = input.float(1.618, "Alert Band 3 Mult (× StDev)", step=0.001, minval=0.0)
sd4AlertMult = input.float(2.618, "Alert Band 4 Mult (× StDev)", step=0.001, minval=0.0)

//====================================================
// TABLE SETTINGS (ALL ADJUSTABLE)
//====================================================
showTable      = input.bool(true, "Show MA Table")
tableBlue      = input.color(color.rgb(10,60,120), "Header Blue")
tableBlueShade = input.int(0, "Header Opacity", minval=0, maxval=100)
tableBlack     = input.color(color.black, "Row Black")
tableBlackSoft = input.color(color.new(color.black,70), "Soft Black")
tableBuyBg     = input.color(color.rgb(0,220,120), "BUY Cell")
tableSellBg    = input.color(color.rgb(255,60,60), "SELL Cell")

//====================================================
// CORE MAs
//====================================================
maNow  = ta.sma(src, maLen)
maPrev = maNow[1]

plot(maNow,  "MA4",    color=liveNowColor,  linewidth=2)
plot(maPrev, "MA4[1]", color=livePrevColor, linewidth=2)

//====================================================
// VLine style mapping
//====================================================
vStyle = vlineStyleInput == "Dotted" ? line.style_dotted :
         vlineStyleInput == "Dashed" ? line.style_dashed :
         line.style_solid

//====================================================
// STORAGE
//====================================================
var float[] patNow  = array.new_float()
var float[] projNow = array.new_float()

var line[] projLinesNow    = array.new_line()
var line[] projLinesPrev   = array.new_line()
var line[] projCrossVLines = array.new_line()

// Forecast cache for alerts (offset 0 = "now")
maxHorizon = 500
var float[] fcU3 = array.new_float()
var float[] fcL3 = array.new_float()
var float[] fcU4 = array.new_float()
var float[] fcL4 = array.new_float()

if barstate.isfirst
    for _ = 0 to maxHorizon
        array.push(fcU3, na), array.push(fcL3, na), array.push(fcU4, na), array.push(fcL4, na)

//====================================================
// BUILD PATTERN WINDOW
//====================================================
startIdx = math.max(startBarsBack, endBarsBack)
endIdx   = math.min(startBarsBack, endBarsBack)
count    = math.max(2, startIdx - endIdx + 1)

array.clear(patNow)
for i = 0 to count - 1
    array.push(patNow, maNow[startIdx - i])

//====================================================
// Compute StDev of (close - MA4) over sampled window (for vline height + alerts)
//====================================================
float stdev = na
if showProj and count >= 2
    float sumErr = 0.0
    for j = 0 to count - 1
        idx = startIdx - j
        sumErr += (close[idx] - maNow[idx])
    float meanErr = sumErr / count

    float variance = 0.0
    for j = 0 to count - 1
        idx = startIdx - j
        float e = (close[idx] - maNow[idx]) - meanErr
        variance += e * e
    variance := variance / count
    stdev := math.sqrt(math.max(0.0, variance))

//====================================================
// BUILD PROJECTION
//====================================================
array.clear(projNow)
if showProj and array.size(patNow) >= 2
    base = array.get(patNow, 0)
    for i = 0 to array.size(patNow) - 1
        val = array.get(patNow, i)
        array.push(projNow, useDeltaAnchor ? maNow + (val - base) : val)

//====================================================
// Shift forecast cache by 1 bar (offset 0 becomes “now”)
//====================================================
array.shift(fcU3), array.push(fcU3, na)
array.shift(fcL3), array.push(fcL3, na)
array.shift(fcU4), array.push(fcU4, na)
array.shift(fcL4), array.push(fcL4, na)

//====================================================
// CLEANUP OLD LINES (per bar)
//====================================================
while array.size(projLinesNow) > 0
    line.delete(array.pop(projLinesNow))
while array.size(projLinesPrev) > 0
    line.delete(array.pop(projLinesPrev))
while array.size(projCrossVLines) > 0
    line.delete(array.pop(projCrossVLines))

//====================================================
// Draw Projection + Projected Cross VLines + write alert cache
//====================================================
atr14 = ta.atr(14)

// even-length VLine height (same for all crosses this bar)
band4WidthNow = not na(stdev) ? (stdev * sd4ForHeight) : na
hV = not na(band4WidthNow) ? (band4WidthNow * vlineHeightMult) : (atr14 * vlineAtrFallbackMult)

if showProj and array.size(projNow) >= 2
    for i = 0 to array.size(projNow) - 2
        int x1 = bar_index + shiftForward + i
        int x2 = x1 + 1

        float yNow1 = array.get(projNow, i)
        float yNow2 = array.get(projNow, i + 1)

        // projected "prev" series is just yNow shifted by 1 segment, seeded with live maPrev
        float yPrev1 = (i == 0) ? maPrev : array.get(projNow, i - 1)
        float yPrev2 = array.get(projNow, i)

        array.push(projLinesNow,  line.new(x1, yNow1,  x2, yNow2,  xloc=xloc.bar_index, color=color.new(projNowColor, 35),  width=2))
        array.push(projLinesPrev, line.new(x1, yPrev1, x2, yPrev2, xloc=xloc.bar_index, color=color.new(projPrevColor,35), width=2))

        // cache projected Band3/Band4 envelopes for alerts (offset = shiftForward+i)
        off = shiftForward + i
        if off >= 0 and off < array.size(fcU3) and not na(stdev)
            w3 = stdev * sd3AlertMult
            w4 = stdev * sd4AlertMult
            array.set(fcU3, off, yNow1 + w3)
            array.set(fcL3, off, yNow1 - w3)
            array.set(fcU4, off, yNow1 + w4)
            array.set(fcL4, off, yNow1 - w4)

        // Projected CROSS VLINES
        if showProjCrossVLines
            bool crossedUp   = (yNow1 < yPrev1) and (yNow2 > yPrev2)
            bool crossedDown = (yNow1 > yPrev1) and (yNow2 < yPrev2)

            if crossedUp or crossedDown
                denom = (yNow2 - yNow1) - (yPrev2 - yPrev1)
                t = denom == 0.0 ? 0.5 : (-(yNow1 - yPrev1)) / denom
                t := math.max(0.0, math.min(1.0, t))
                yCross = yNow1 + (yNow2 - yNow1) * t

                vcol = crossedUp ? vlineBullColor : vlineBearColor

                vln = line.new(
                    x2, yCross - hV,
                    x2, yCross + hV,
                    xloc=xloc.bar_index,
                    extend=extend.none,
                    color=vcol,
                    style=vStyle,
                    width=vlineWidth
                )
                array.push(projCrossVLines, vln)

//====================================================
// Alerts: Band3 / Band4 breach at offset 0 ("now")
//====================================================
float pxHi = useWicks ? high : close
float pxLo = useWicks ? low  : close

u3 = array.get(fcU3, 0)
l3 = array.get(fcL3, 0)
u4 = array.get(fcU4, 0)
l4 = array.get(fcL4, 0)

band3Breach = enableAlerts and alertBand3 and not na(u3) and not na(l3) and (pxHi > u3 or pxLo < l3)
band4Breach = enableAlerts and alertBand4 and not na(u4) and not na(l4) and (pxHi > u4 or pxLo < l4)

alertcondition(band3Breach, "Band 3 Breach (Stretch)", "Band 3 breach: price outside projected ±Band3 envelope.")
alertcondition(band4Breach, "Band 4 Breach (Invalidation)", "Band 4 breach: price outside projected ±Band4 envelope.")

//====================================================
// TABLE LOGIC (NO table.clear)
//====================================================
bullCross = ta.crossover(maNow, maPrev)
bearCross = ta.crossunder(maNow, maPrev)

var string lastSignal = "No cross yet"
if bullCross
    lastSignal := "BUY (MA4 crossed ABOVE MA4[1])"
else if bearCross
    lastSignal := "SELL (MA4 crossed BELOW MA4[1])"

alignText = maNow > maPrev ? "Bullish" : maNow < maPrev ? "Bearish" : "Neutral"

var table maTable = table.new(position.top_right, 3, 4, border_width=1)

if barstate.islast and showTable
    blueBg = color.new(tableBlue, tableBlueShade)

    table.cell(maTable, 0, 0, "Item",   bgcolor=blueBg,     text_color=color.white)
    table.cell(maTable, 1, 0, "Value",  bgcolor=blueBg,     text_color=color.white)
    table.cell(maTable, 2, 0, "Status", bgcolor=blueBg,     text_color=color.white)

    table.cell(maTable, 0, 1, "MA4",    bgcolor=tableBlack, text_color=color.white)
    table.cell(maTable, 1, 1, str.tostring(maNow, format.mintick), bgcolor=tableBlack, text_color=color.white)
    table.cell(maTable, 2, 1, maNow > maPrev ? "Above" : "Below", bgcolor=tableBlack, text_color=color.white)

    table.cell(maTable, 0, 2, "MA4[1]", bgcolor=tableBlack, text_color=color.white)
    table.cell(maTable, 1, 2, str.tostring(maPrev, format.mintick), bgcolor=tableBlack, text_color=color.white)
    table.cell(maTable, 2, 2, maPrev < maNow ? "Below" : "Above", bgcolor=tableBlack, text_color=color.white)

    sigBg = str.startswith(lastSignal, "BUY") ? tableBuyBg : str.startswith(lastSignal, "SELL") ? tableSellBg : color.new(color.gray, 80)

    table.cell(maTable, 0, 3, "Alignment", bgcolor=blueBg,        text_color=color.white)
    table.cell(maTable, 1, 3, alignText,  bgcolor=tableBlackSoft, text_color=color.white)
    table.cell(maTable, 2, 3, lastSignal, bgcolor=sigBg,         text_color=color.white)
