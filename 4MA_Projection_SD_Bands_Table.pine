// =====================================================================
// Infinity Signal
// Indicator: 4MA / 4MA[1] — Projection + 4 SD Bands + Fills + Alerts + Cross VLines + Table
// Version: v1.0.0
// Last Updated: 2026-02-01
// License: See LICENSE file in this repository (or repository root)
// =====================================================================

//@version=6
indicator("4MA / 4MA[1] — Projection + 4 SD Bands + Fills + Alerts + Cross VLines + Table",
     overlay=true, max_lines_count=500, max_labels_count=500, max_bars_back=5000)

//====================================================
// Inputs
//====================================================
maLen         = input.int(4, "MA Length", minval=1)
src           = input.source(close, "Source")

// LIVE MA COLORS
liveNowColor  = input.color(color.blue, "Live 4MA Color")
livePrevColor = input.color(color.red,  "Live 4MA[1] Color")

// Pattern window + shift
// ✅ HARD PRESET per request:
startBarsBack = 1474
endBarsBack   = 1460
shiftForward  = input.int(50,  "Shift Pattern Forward (bars)", minval=0)

// Projection options
useDeltaAnchor = input.bool(true, "Delta-anchor projection to current MA values")
showProj       = input.bool(true, "Show Projection")

projNowColor   = input.color(color.new(color.aqua, 0),   "Projected 4MA Color")
projPrevColor  = input.color(color.new(color.orange, 0), "Projected 4MA[1] Color")

//====================================================
// Projected Cross Markers (Projected MA4 vs Projected MA4[1])
// Vertical Lines — EVEN LENGTH + DEVIATION-BASED HEIGHT
//====================================================
showProjCrossVLines = input.bool(true, "Mark projected crosses (Vertical Lines)")
vlineBullColor      = input.color(color.lime, "Bull Cross VLine Color")
vlineBearColor      = input.color(color.red,  "Bear Cross VLine Color")
vlineWidth          = input.int(2, "VLine Width", minval=1, maxval=4)
vlineStyleInput     = input.string("Dotted", "VLine Style", options=["Solid","Dotted","Dashed"])

// Height behavior: use deviation width (preferred), fallback to ATR if stdev is na.
vlineHeightMult     = input.float(1.0, "VLine Height = (Band4 width) ×", minval=0.1, step=0.1)
vlineAtrFallbackMult= input.float(0.8, "Fallback Height = ATR ×", minval=0.1, step=0.1)

//====================================================
// 4 Independent SD Band Ladder (Fib-style)
//====================================================
showBands      = input.bool(true, "Show 4 SD Bands (Independent)")
bandsOpacity   = input.int(80, "Band Line Opacity (0=solid, 100=transparent)", minval=0, maxval=100)

// Manual multipliers (used when TF-lock is OFF)
sd1 = input.float(0.50,  "Band 1 Mult (× StDev)", step=0.001, minval=0.0)
sd2 = input.float(1.00,  "Band 2 Mult (× StDev)", step=0.001, minval=0.0)
sd3 = input.float(1.618, "Band 3 Mult (× StDev)", step=0.001, minval=0.0)
sd4 = input.float(2.618, "Band 4 Mult (× StDev)", step=0.001, minval=0.0)

// Band colors
band1Color = input.color(color.new(color.aqua, 0),    "Band 1 Color")
band2Color = input.color(color.new(color.yellow, 0),  "Band 2 Color")
band3Color = input.color(color.new(color.fuchsia, 0), "Band 3 Color")
band4Color = input.color(color.new(color.white, 0),   "Band 4 Color")

//====================================================
// Soft fills between selected levels
//====================================================
showFills      = input.bool(true, "Soft Fills Between Levels")
fill12         = input.bool(true,  "Fill between Band1 ↔ Band2")
fill23         = input.bool(true,  "Fill between Band2 ↔ Band3")
fill34         = input.bool(false, "Fill between Band3 ↔ Band4")
fillsOpacity   = input.int(92, "Fill Opacity (higher = softer)", minval=0, maxval=100)

//====================================================
// Auto-fade inner bands when volatility compresses
//====================================================
autoFade       = input.bool(true, "Auto-fade inner bands on volatility compression")
volLookback    = input.int(100, "Volatility Lookback (bars)", minval=10)
fadeStrength   = input.float(1.0, "Fade Strength", minval=0.0, step=0.1)

//====================================================
// Timeframe-locked band ratios
//====================================================
lockByTF = input.bool(true, "Lock band ratios by timeframe")

// 1H
tf1h_sd1 = input.float(0.50,  "1H: Band1 Mult", step=0.001, minval=0.0)
tf1h_sd2 = input.float(1.00,  "1H: Band2 Mult", step=0.001, minval=0.0)
tf1h_sd3 = input.float(1.618, "1H: Band3 Mult", step=0.001, minval=0.0)
tf1h_sd4 = input.float(2.618, "1H: Band4 Mult", step=0.001, minval=0.0)

// 4H
tf4h_sd1 = input.float(0.618, "4H: Band1 Mult", step=0.001, minval=0.0)
tf4h_sd2 = input.float(1.272, "4H: Band2 Mult", step=0.001, minval=0.0)
tf4h_sd3 = input.float(2.000, "4H: Band3 Mult", step=0.001, minval=0.0)
tf4h_sd4 = input.float(2.618, "4H: Band4 Mult", step=0.001, minval=0.0)

// 1D
tf1d_sd1 = input.float(0.382, "1D: Band1 Mult", step=0.001, minval=0.0)
tf1d_sd2 = input.float(0.618, "1D: Band2 Mult", step=0.001, minval=0.0)
tf1d_sd3 = input.float(1.000, "1D: Band3 Mult", step=0.001, minval=0.0)
tf1d_sd4 = input.float(1.618, "1D: Band4 Mult", step=0.001, minval=0.0)

// 1W+
tf1w_sd1 = input.float(0.236, "1W+: Band1 Mult", step=0.001, minval=0.0)
tf1w_sd2 = input.float(0.382, "1W+: Band2 Mult", step=0.001, minval=0.0)
tf1w_sd3 = input.float(0.618, "1W+: Band3 Mult", step=0.001, minval=0.0)
tf1w_sd4 = input.float(1.000, "1W+: Band4 Mult", step=0.001, minval=0.0)

//====================================================
// Alerts
//====================================================
enableAlerts   = input.bool(true, "Enable Breach Alerts")
useWicks       = input.bool(true, "Use Wicks (High/Low) for breach check")
alertBand3     = input.bool(true,  "Alert: Band 3 breach = Momentum Stretch")
alertBand4     = input.bool(true,  "Alert: Band 4 breach = Projection Invalidated")

//====================================================
// TABLE (integrated)
//====================================================
showTable = input.bool(true, "Show MA Cross Table")

// Blue only for: header cells + Alignment label cell
tableBlue        = input.color(color.rgb(10, 60, 120), "Table Blue (Header/Alignment label)")
tableBlueShade   = input.int(0, "Blue Shade (0=solid, 100=transparent)", minval=0, maxval=100)

// Black rows/cells
tableBlack       = input.color(color.new(color.black, 0), "Table Black (Rows)")
tableBlackSoft   = input.color(color.new(color.black, 70), "Table Black (Soft)")

// Adjustable BUY/SELL cell backgrounds (your request)
tableBuyBg  = input.color(color.rgb(0, 220, 120), "BUY Cell Background (Adjustable)")
tableSellBg = input.color(color.rgb(255, 60, 60), "SELL Cell Background (Adjustable)")

//====================================================
// Core MAs
//====================================================
maNow  = ta.sma(src, maLen)   // 4MA
maPrev = maNow[1]             // 4MA[1]

plot(maNow,  title="MA4",    linewidth=2, color=liveNowColor)
plot(maPrev, title="MA4[1]", linewidth=2, color=livePrevColor)

//====================================================
// TF multiplier selection
//====================================================
is1h    = timeframe.isminutes and timeframe.multiplier == 60
is4h    = timeframe.isminutes and timeframe.multiplier == 240
is1d    = timeframe.isdaily
is1wPls = timeframe.isweekly or timeframe.ismonthly

sd1Eff = lockByTF ? (is1h ? tf1h_sd1 : is4h ? tf4h_sd1 : is1d ? tf1d_sd1 : is1wPls ? tf1w_sd1 : sd1) : sd1
sd2Eff = lockByTF ? (is1h ? tf1h_sd2 : is4h ? tf4h_sd2 : is1d ? tf1d_sd2 : is1wPls ? tf1w_sd2 : sd2) : sd2
sd3Eff = lockByTF ? (is1h ? tf1h_sd3 : is4h ? tf4h_sd3 : is1d ? tf1d_sd3 : is1wPls ? tf1w_sd3 : sd3) : sd3
sd4Eff = lockByTF ? (is1h ? tf1h_sd4 : is4h ? tf4h_sd4 : is1d ? tf1d_sd4 : is1wPls ? tf1w_sd4 : sd4) : sd4

//====================================================
// VLine style mapping
//====================================================
vStyle = vlineStyleInput == "Dotted" ? line.style_dotted :
         vlineStyleInput == "Dashed" ? line.style_dashed :
         line.style_solid

//====================================================
// Storage
//====================================================
var float[] patNow  = array.new_float()
var float[] projNow = array.new_float()

var line[]  projLinesNow  = array.new_line()
var line[]  projLinesPrev = array.new_line()

var line[] projCrossVLines = array.new_line()

var line[] b1U = array.new_line()
var line[] b1L = array.new_line()
var line[] b2U = array.new_line()
var line[] b2L = array.new_line()
var line[] b3U = array.new_line()
var line[] b3L = array.new_line()
var line[] b4U = array.new_line()
var line[] b4L = array.new_line()

var linefill[] fU12 = array.new_linefill()
var linefill[] fL12 = array.new_linefill()
var linefill[] fU23 = array.new_linefill()
var linefill[] fL23 = array.new_linefill()
var linefill[] fU34 = array.new_linefill()
var linefill[] fL34 = array.new_linefill()

// Forecast cache for alerts
maxHorizon = 500
var float[] fcU3 = array.new_float()
var float[] fcL3 = array.new_float()
var float[] fcU4 = array.new_float()
var float[] fcL4 = array.new_float()

if barstate.isfirst
    for _ = 0 to maxHorizon
        array.push(fcU3, na), array.push(fcL3, na), array.push(fcU4, na), array.push(fcL4, na)

//====================================================
// Helper: draw band (upper+lower) — Pine-safe (no returns)
//====================================================
f_draw_band(_x1, _x2, _y1, _y2, _stdev, _mult, _col, _opacity, _storeU, _storeL) =>
    float w = _stdev * _mult
    color c = color.new(_col, _opacity)
    up = line.new(_x1, _y1 + w, _x2, _y2 + w, xloc=xloc.bar_index, extend=extend.none, color=c, width=1)
    lo = line.new(_x1, _y1 - w, _x2, _y2 - w, xloc=xloc.bar_index, extend=extend.none, color=c, width=1)
    array.push(_storeU, up)
    array.push(_storeL, lo)

//====================================================
// Cleanup per bar
//====================================================
while array.size(projLinesNow) > 0
    line.delete(array.pop(projLinesNow))
while array.size(projLinesPrev) > 0
    line.delete(array.pop(projLinesPrev))
while array.size(projCrossVLines) > 0
    line.delete(array.pop(projCrossVLines))

while array.size(b1U) > 0
    line.delete(array.pop(b1U))
while array.size(b1L) > 0
    line.delete(array.pop(b1L))
while array.size(b2U) > 0
    line.delete(array.pop(b2U))
while array.size(b2L) > 0
    line.delete(array.pop(b2L))
while array.size(b3U) > 0
    line.delete(array.pop(b3U))
while array.size(b3L) > 0
    line.delete(array.pop(b3L))
while array.size(b4U) > 0
    line.delete(array.pop(b4U))
while array.size(b4L) > 0
    line.delete(array.pop(b4L))

while array.size(fU12) > 0
    linefill.delete(array.pop(fU12))
while array.size(fL12) > 0
    linefill.delete(array.pop(fL12))
while array.size(fU23) > 0
    linefill.delete(array.pop(fU23))
while array.size(fL23) > 0
    linefill.delete(array.pop(fL23))
while array.size(fU34) > 0
    linefill.delete(array.pop(fU34))
while array.size(fL34) > 0
    linefill.delete(array.pop(fL34))

//====================================================
// Line budgeting
//====================================================
maxLinesAllowed  = 500
reserveLines     = 170
maxPatternPoints = math.floor((maxLinesAllowed - reserveLines) / 11) + 1

//====================================================
// Build pattern window (oldest -> newest)
//====================================================
startIdx = math.max(startBarsBack, endBarsBack)
endIdx   = math.min(startBarsBack, endBarsBack)
count    = startIdx - endIdx + 1

if count < 2
    count := 2
if count > maxPatternPoints
    count    := maxPatternPoints
    startIdx := endIdx + count - 1

array.clear(patNow)
for j = 0 to count - 1
    idx = startIdx - j
    array.push(patNow, maNow[idx])

//====================================================
// Compute StDev of (close - MA4) over sampled window
//====================================================
float stdev = na
if showProj and count >= 2
    float sumErr = 0.0
    for j = 0 to count - 1
        idx = startIdx - j
        sumErr += (close[idx] - maNow[idx])
    float meanErr = sumErr / count

    float variance = 0.0
    for j = 0 to count - 1
        idx = startIdx - j
        float e = (close[idx] - maNow[idx]) - meanErr
        variance += e * e
    variance := variance / count
    stdev := math.sqrt(math.max(0.0, variance))

//====================================================
// Auto-fade inner bands under compression
//====================================================
float stdevMA = ta.sma(stdev, volLookback)
float ratio   = (not na(stdev) and not na(stdevMA) and stdevMA != 0.0) ? (stdev / stdevMA) : 1.0
ratio := math.max(0.0, math.min(2.0, ratio))

int extraFade = 0
if autoFade
    extraFade := int(math.max(0.0, (1.0 - ratio) * 100.0 * fadeStrength))

innerOpacity = math.min(100, bandsOpacity + extraFade)
outerOpacity = bandsOpacity

fillsOpacityInner = math.min(100, fillsOpacity + int(extraFade * 0.6))
fillsOpacityOuter = fillsOpacity

//====================================================
// Build projected MA4 points
//====================================================
array.clear(projNow)
if showProj and array.size(patNow) >= 2
    float past0 = array.get(patNow, 0)
    float cur0  = maNow
    for i = 0 to array.size(patNow) - 1
        float p = array.get(patNow, i)
        float y = useDeltaAnchor ? (cur0 + (p - past0)) : p
        array.push(projNow, y)

//====================================================
// Shift forecast cache by 1 bar (offset 0 becomes “now”)
//====================================================
array.shift(fcU3), array.push(fcU3, na)
array.shift(fcL3), array.push(fcL3, na)
array.shift(fcU4), array.push(fcU4, na)
array.shift(fcL4), array.push(fcL4, na)

//====================================================
// Draw projection + bands + fills + EVEN vertical cross lines
//====================================================
atr14 = ta.atr(14)

// ONE height value used for ALL projected cross vlines in this bar => even length.
band4WidthNow = (not na(stdev) ? (stdev * sd4Eff) : na)
hV = not na(band4WidthNow) ? (band4WidthNow * vlineHeightMult) : (atr14 * vlineAtrFallbackMult)

if showProj and array.size(projNow) >= 2
    for i = 0 to array.size(projNow) - 2
        float yNow1 = array.get(projNow, i)
        float yNow2 = array.get(projNow, i + 1)

        float yPrev1 = (i == 0) ? maPrev : array.get(projNow, i - 1)
        float yPrev2 = array.get(projNow, i)

        int x1 = bar_index + shiftForward + i
        int x2 = x1 + 1

        ln1 = line.new(x1, yNow1,  x2, yNow2,  xloc=xloc.bar_index, extend=extend.none, color=color.new(projNowColor,  35), width=2)
        ln2 = line.new(x1, yPrev1, x2, yPrev2, xloc=xloc.bar_index, extend=extend.none, color=color.new(projPrevColor, 35), width=2)

        array.push(projLinesNow, ln1)
        array.push(projLinesPrev, ln2)

        if showBands and not na(stdev)
            f_draw_band(x1, x2, yNow1, yNow2, stdev, sd1Eff, band1Color, innerOpacity, b1U, b1L)
            f_draw_band(x1, x2, yNow1, yNow2, stdev, sd2Eff, band2Color, innerOpacity, b2U, b2L)
            f_draw_band(x1, x2, yNow1, yNow2, stdev, sd3Eff, band3Color, outerOpacity, b3U, b3L)
            f_draw_band(x1, x2, yNow1, yNow2, stdev, sd4Eff, band4Color, outerOpacity, b4U, b4L)

            if showFills
                if fill12 and array.size(b1U) > 0 and array.size(b2U) > 0
                    c = color.new(band1Color, fillsOpacityInner)
                    array.push(fU12, linefill.new(array.get(b1U, array.size(b1U)-1), array.get(b2U, array.size(b2U)-1), c))
                    array.push(fL12, linefill.new(array.get(b1L, array.size(b1L)-1), array.get(b2L, array.size(b2L)-1), c))

                if fill23 and array.size(b2U) > 0 and array.size(b3U) > 0
                    c = color.new(band2Color, fillsOpacityInner)
                    array.push(fU23, linefill.new(array.get(b2U, array.size(b2U)-1), array.get(b3U, array.size(b3U)-1), c))
                    array.push(fL23, linefill.new(array.get(b2L, array.size(b2L)-1), array.get(b3L, array.size(b3L)-1), c))

                if fill34 and array.size(b3U) > 0 and array.size(b4U) > 0
                    c = color.new(band3Color, fillsOpacityOuter)
                    array.push(fU34, linefill.new(array.get(b3U, array.size(b3U)-1), array.get(b4U, array.size(b4U)-1), c))
                    array.push(fL34, linefill.new(array.get(b3L, array.size(b3L)-1), array.get(b4L, array.size(b4L)-1), c))

            off = shiftForward + i
            if off >= 0 and off < array.size(fcU3)
                w3 = stdev * sd3Eff
                w4 = stdev * sd4Eff
                array.set(fcU3, off, yNow1 + w3)
                array.set(fcL3, off, yNow1 - w3)
                array.set(fcU4, off, yNow1 + w4)
                array.set(fcL4, off, yNow1 - w4)

        // Projected CROSS VLINES (even + deviation-based)
        if showProjCrossVLines
            bool crossedUp   = (yNow1 < yPrev1) and (yNow2 > yPrev2)
            bool crossedDown = (yNow1 > yPrev1) and (yNow2 < yPrev2)

            if crossedUp or crossedDown
                denom = (yNow2 - yNow1) - (yPrev2 - yPrev1)
                t = denom == 0.0 ? 0.5 : (-(yNow1 - yPrev1)) / denom
                t := math.max(0.0, math.min(1.0, t))
                yCross = yNow1 + (yNow2 - yNow1) * t

                vcol = crossedUp ? vlineBullColor : vlineBearColor

                vln = line.new(
                    x2, yCross - hV,
                    x2, yCross + hV,
                    xloc=xloc.bar_index,
                    extend=extend.none,
                    color=vcol,
                    style=vStyle,
                    width=vlineWidth
                )
                array.push(projCrossVLines, vln)

//====================================================
// Breach detection + alerts (per band)
//====================================================
float pxHi = useWicks ? high : close
float pxLo = useWicks ? low  : close

u3 = array.get(fcU3, 0)
l3 = array.get(fcL3, 0)
u4 = array.get(fcU4, 0)
l4 = array.get(fcL4, 0)

band3Breach = enableAlerts and alertBand3 and not na(u3) and not na(l3) and (pxHi > u3 or pxLo < l3)
band4Breach = enableAlerts and alertBand4 and not na(u4) and not na(l4) and (pxHi > u4 or pxLo < l4)

alertcondition(band3Breach, "Band 3 Breach (Momentum Stretch)", "Band 3 SD breach: Momentum stretch (price outside projected ±Band3).")
alertcondition(band4Breach, "Band 4 Breach (Projection Invalidated)", "Band 4 SD breach: Projection invalidated (price outside projected ±Band4).")

//====================================================
// TABLE LOGIC (from your Cross Table)
//====================================================
// Cross conditions (only true on the bar of the cross)
bullCross = ta.crossover(maNow, maPrev)
bearCross = ta.crossunder(maNow, maPrev)

// Track last signal text
var string lastSignal = "No cross yet"
if bullCross
    lastSignal := "BUY (MA4 crossed ABOVE MA4[1])"
else if bearCross
    lastSignal := "SELL (MA4 crossed BELOW MA4[1])"

// Current alignment
string alignText = maNow > maPrev ? "Bullish (MA4 > MA4[1])" :
                   maNow < maPrev ? "Bearish (MA4 < MA4[1])" :
                   "Neutral (MA4 = MA4[1])"

// Table
var table maTable = table.new(position.top_right, 3, 4, border_width=1)

blueBg = color.new(tableBlue, tableBlueShade)

// Update table on last bar
if barstate.islast and showTable
    // Header row (BLUE)
    table.cell(maTable, 0, 0, "Item",   text_color=color.white, bgcolor=blueBg)
    table.cell(maTable, 1, 0, "Value",  text_color=color.white, bgcolor=blueBg)
    table.cell(maTable, 2, 0, "Status", text_color=color.white, bgcolor=blueBg)

    // Row 1: MA4 (BLACK)
    table.cell(maTable, 0, 1, "MA4", text_color=color.white, bgcolor=tableBlack)
    table.cell(maTable, 1, 1, str.tostring(maNow, format.mintick), text_color=color.white, bgcolor=tableBlack)
    table.cell(maTable, 2, 1,
         (maNow > maPrev ? "Above MA4[1]" : maNow < maPrev ? "Below MA4[1]" : "Equal"),
         text_color=color.white, bgcolor=tableBlack)

    // Row 2: MA4[1] (BLACK)
    table.cell(maTable, 0, 2, "MA4[1]", text_color=color.white, bgcolor=tableBlack)
    table.cell(maTable, 1, 2, str.tostring(maPrev, format.mintick), text_color=color.white, bgcolor=tableBlack)
    table.cell(maTable, 2, 2,
         (maPrev < maNow ? "Below MA4" : maPrev > maNow ? "Above MA4" : "Equal"),
         text_color=color.white, bgcolor=tableBlack)

    // Row 3: Alignment label BLUE, alignment text BLACK, signal cell adjustable BUY/SELL
    sigBg =
         str.startswith(lastSignal, "BUY")  ? tableBuyBg :
         str.startswith(lastSignal, "SELL") ? tableSellBg :
         color.new(color.gray, 80)

    table.cell(maTable, 0, 3, "Alignment", text_color=color.white, bgcolor=blueBg)          // BLUE
    table.cell(maTable, 1, 3, alignText,   text_color=color.white, bgcolor=tableBlackSoft) // BLACK
    table.cell(maTable, 2, 3, lastSignal,  text_color=color.white, bgcolor=sigBg)          // BUY/SELL adjustable
