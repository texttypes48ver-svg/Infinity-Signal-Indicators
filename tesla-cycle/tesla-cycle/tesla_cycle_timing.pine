//@version=6
indicator("TSLA Cycle Timing — 122-Day Reversal Map (Adaptive Framework)",
     overlay=true, max_lines_count=500, max_labels_count=500, max_boxes_count=500)

//=============================================================================
// TSLA Cycle Timing — 23-Point Map + Inversion Points
//-----------------------------------------------------------------------------
// What this does:
// • Draws repeating vertical timing markers within a cycle length (default 122 bars)
// • Points 1–23 are the TSLA-derived "set" reversal zones (timing windows)
// • Points 24–26 are OPTIONAL user markers, with 24 & 25 labeled as Inversion Points
//
// What "Inversion Points" mean (conceptual, user-facing):
// • Sometimes TSLA's sequence flips (high/low order swaps) due to a structural deviation.
// • These optional inversion markers let you annotate where the flip appears to occur.
// • The goal is to keep the broader timing map stable while acknowledging regime shifts.
//
// Notes:
// • This is a timing framework (vertical zones), not an automatic buy/sell system.
// • Use with a clean chart for publication (as TradingView recommends).
//=============================================================================


//====================
// Core Inputs
//====================
cycleLen         = input.int(122,  "Cycle Length (bars)", minval=1)
barsBackLookback = input.int(2748, "Lookback Bars (how far back to draw)", minval=0)
futureCycles     = input.int(2,    "Future Cycles", minval=0, maxval=20)
anchorBarsBack   = input.int(0,    "Bars Back to Current Cycle Start", minval=0)

//====================
// Number Controls (Labels ON the Lines)
//====================
showNumsCurrent  = input.bool(true,  "Show Labels — Current Cycle")
showNumsPast     = input.bool(true,  "Show Labels — Past Cycles (behind price)")
showNumsFuture   = input.bool(true,  "Show Labels — Future Cycles")

// Safety caps (to avoid max_labels_count blowups)
pastNumsCycles   = input.int(25, "Past Cycles To Label (newest -> oldest)", minval=0, maxval=25)
futNumsCycles    = input.int(6,  "Future Cycles To Label (nearest)", minval=0, maxval=20)

numStyleIn       = input.string("Colored Badge", "Label Style", options=["Colored Badge","Colored Text"])
labelSizeIn      = input.string("Small", "Label Size", options=["Tiny","Small","Normal","Large"])
labelAtTop       = input.bool(true, "Labels At Top")
labelYOffset     = input.float(0.0, "Label Vertical Offset (price units)", step=0.0001)

//====================
// Window Bands
//====================
showWindow       = input.bool(true, "Show ± Window Bands")
tolBars          = input.int(1, "Window ± Bars", minval=0, maxval=20)
windowOpacity    = input.int(88, "Window Opacity", minval=0, maxval=100)

//====================
// Cycle Visibility
//====================
showPast         = input.bool(true, "Show Past Cycles")
showCurrent      = input.bool(true, "Show Current Cycle")
showFuture       = input.bool(true, "Show Future Cycles")

// PERFORMANCE SAFETY SWITCH
pastLinesOnly    = input.bool(true, "Past Cycles: Lines Only (recommended)",
     tooltip="ON = Past cycles draw ONLY vertical lines (no boxes). Keeps rendering stable at large lookbacks.")

// Opacity controls (applied to per-point colors)
curFutOpacity    = input.int(0,  "Current/Future Opacity", minval=0, maxval=100)
pastOldestOp     = input.int(85, "Past Oldest Opacity", minval=0, maxval=100)
pastNewestOp     = input.int(25, "Past Newest Opacity", minval=0, maxval=100)


//====================================================
// Per-Point Colors (26 total: 23 set points + 3 optional)
//====================================================
string GRP_COL = "Point Colors"
c1  = input.color(color.red,     "Point 1",  group=GRP_COL)
c2  = input.color(color.blue,    "Point 2",  group=GRP_COL)
c3  = input.color(color.orange,  "Point 3",  group=GRP_COL)
c4  = input.color(color.green,   "Point 4",  group=GRP_COL)
c5  = input.color(color.gray,    "Point 5",  group=GRP_COL)
c6  = input.color(color.purple,  "Point 6",  group=GRP_COL)
c7  = input.color(color.yellow,  "Point 7",  group=GRP_COL)
c8  = input.color(color.teal,    "Point 8",  group=GRP_COL)
c9  = input.color(color.fuchsia, "Point 9",  group=GRP_COL)
c10 = input.color(color.aqua,    "Point 10", group=GRP_COL)
c11 = input.color(color.red,     "Point 11", group=GRP_COL)
c12 = input.color(color.blue,    "Point 12", group=GRP_COL)
c13 = input.color(color.orange,  "Point 13", group=GRP_COL)
c14 = input.color(color.green,   "Point 14", group=GRP_COL)
c15 = input.color(color.gray,    "Point 15", group=GRP_COL)
c16 = input.color(color.purple,  "Point 16", group=GRP_COL)
c17 = input.color(color.yellow,  "Point 17", group=GRP_COL)
c18 = input.color(color.teal,    "Point 18", group=GRP_COL)
c19 = input.color(color.fuchsia, "Point 19", group=GRP_COL)
c20 = input.color(color.aqua,    "Point 20", group=GRP_COL)
c21 = input.color(color.red,     "Point 21", group=GRP_COL)
c22 = input.color(color.blue,    "Point 22", group=GRP_COL)
c23 = input.color(color.orange,  "Point 23", group=GRP_COL)

// Extra optional points
c24 = input.color(color.yellow,  "Inversion Point A (24)", group=GRP_COL)
c25 = input.color(color.aqua,    "Inversion Point B (25)", group=GRP_COL)
c26 = input.color(color.fuchsia, "Optional Point C (26)",  group=GRP_COL)


//====================
// Point Toggles (26)
//====================
string GRP_SHOW = "Point Visibility"
en1  = input.bool(true,  "Show Point 1",  group=GRP_SHOW)
en2  = input.bool(true,  "Show Point 2",  group=GRP_SHOW)
en3  = input.bool(true,  "Show Point 3",  group=GRP_SHOW)
en4  = input.bool(true,  "Show Point 4",  group=GRP_SHOW)
en5  = input.bool(true,  "Show Point 5",  group=GRP_SHOW)
en6  = input.bool(true,  "Show Point 6",  group=GRP_SHOW)
en7  = input.bool(true,  "Show Point 7",  group=GRP_SHOW)
en8  = input.bool(true,  "Show Point 8",  group=GRP_SHOW)
en9  = input.bool(true,  "Show Point 9",  group=GRP_SHOW)
en10 = input.bool(true,  "Show Point 10", group=GRP_SHOW)
en11 = input.bool(true,  "Show Point 11", group=GRP_SHOW)
en12 = input.bool(true,  "Show Point 12", group=GRP_SHOW)
en13 = input.bool(true,  "Show Point 13", group=GRP_SHOW)
en14 = input.bool(true,  "Show Point 14", group=GRP_SHOW)
en15 = input.bool(true,  "Show Point 15", group=GRP_SHOW)
en16 = input.bool(true,  "Show Point 16", group=GRP_SHOW)
en17 = input.bool(true,  "Show Point 17", group=GRP_SHOW)
en18 = input.bool(true,  "Show Point 18", group=GRP_SHOW)
en19 = input.bool(true,  "Show Point 19", group=GRP_SHOW)
en20 = input.bool(true,  "Show Point 20", group=GRP_SHOW)
en21 = input.bool(true,  "Show Point 21", group=GRP_SHOW)
en22 = input.bool(true,  "Show Point 22", group=GRP_SHOW)
en23 = input.bool(true,  "Show Point 23", group=GRP_SHOW)

// Default OFF so they behave like "blank possible points" until user enables them
en24 = input.bool(false, "Show Inversion Point A (24)", group=GRP_SHOW)
en25 = input.bool(false, "Show Inversion Point B (25)", group=GRP_SHOW)
en26 = input.bool(false, "Show Optional Point C (26)",  group=GRP_SHOW)


//====================
// Offsets (TSLA defaults from your settings)
//====================
string GRP_OFF = "Point Offsets (bars from cycle start)"
p1  = input.int(46,  "Point 1 Offset",  minval=0, group=GRP_OFF)
p2  = input.int(52,  "Point 2 Offset",  minval=0, group=GRP_OFF)
p3  = input.int(57,  "Point 3 Offset",  minval=0, group=GRP_OFF)
p4  = input.int(62,  "Point 4 Offset",  minval=0, group=GRP_OFF)
p5  = input.int(66,  "Point 5 Offset",  minval=0, group=GRP_OFF)
p6  = input.int(70,  "Point 6 Offset",  minval=0, group=GRP_OFF)
p7  = input.int(77,  "Point 7 Offset",  minval=0, group=GRP_OFF)
p8  = input.int(84,  "Point 8 Offset",  minval=0, group=GRP_OFF)
p9  = input.int(90,  "Point 9 Offset",  minval=0, group=GRP_OFF)
p10 = input.int(97,  "Point 10 Offset", minval=0, group=GRP_OFF)
p11 = input.int(100, "Point 11 Offset", minval=0, group=GRP_OFF)
p12 = input.int(106, "Point 12 Offset", minval=0, group=GRP_OFF)
p13 = input.int(111, "Point 13 Offset", minval=0, group=GRP_OFF)
p14 = input.int(116, "Point 14 Offset", minval=0, group=GRP_OFF)
p15 = input.int(121, "Point 15 Offset", minval=0, group=GRP_OFF)
p16 = input.int(125, "Point 16 Offset", minval=0, group=GRP_OFF)
p17 = input.int(128, "Point 17 Offset", minval=0, group=GRP_OFF)
p18 = input.int(135, "Point 18 Offset", minval=0, group=GRP_OFF)
p19 = input.int(141, "Point 19 Offset", minval=0, group=GRP_OFF)
p20 = input.int(146, "Point 20 Offset", minval=0, group=GRP_OFF)
p21 = input.int(150, "Point 21 Offset", minval=0, group=GRP_OFF)
p22 = input.int(156, "Point 22 Offset", minval=0, group=GRP_OFF)
p23 = input.int(163, "Point 23 Offset", minval=0, group=GRP_OFF)

// “Blank” user points (default 0, user edits as needed)
p24 = input.int(0,   "Inversion Point A Offset (24)", minval=0, group=GRP_OFF)
p25 = input.int(0,   "Inversion Point B Offset (25)", minval=0, group=GRP_OFF)
p26 = input.int(0,   "Optional Point C Offset (26)",  minval=0, group=GRP_OFF)


//====================
// Label size helper
//====================
f_labelSize() =>
    s = size.small
    if labelSizeIn == "Tiny"
        s := size.tiny
    else if labelSizeIn == "Normal"
        s := size.normal
    else if labelSizeIn == "Large"
        s := size.large
    else
        s := size.small
    s


//====================
// Anchor + Range
//====================
curStart = bar_index - anchorBarsBack
xMin = bar_index - barsBackLookback
xMax = bar_index + (futureCycles * cycleLen)


//====================
// Object storage
//====================
var line[]  gLines = array.new_line()
var label[] gLabs  = array.new_label()
var box[]   gBoxes = array.new_box()

f_clearAll() =>
    int nL = array.size(gLines)
    if nL > 0
        for i = nL - 1 to 0
            line.delete(array.get(gLines, i))
    array.clear(gLines)

    int nB = array.size(gBoxes)
    if nB > 0
        for i = nB - 1 to 0
            box.delete(array.get(gBoxes, i))
    array.clear(gBoxes)

    int nLb = array.size(gLabs)
    if nLb > 0
        for i = nLb - 1 to 0
            label.delete(array.get(gLabs, i))
    array.clear(gLabs)


//====================
// Arrays (26-point model, TSLA-specific)
//====================
var int N = 26
var bool[]  ens   = array.new_bool(N, true)
var int[]   offs  = array.new_int(N, 0)
var color[] cols  = array.new_color(N, color.gray)
var string[] txts = array.new_string(N, "")

f_refreshArrays() =>
    // enables
    array.set(ens, 0, en1),  array.set(ens, 1, en2),  array.set(ens, 2, en3),  array.set(ens, 3, en4),  array.set(ens, 4, en5)
    array.set(ens, 5, en6),  array.set(ens, 6, en7),  array.set(ens, 7, en8),  array.set(ens, 8, en9),  array.set(ens, 9, en10)
    array.set(ens,10, en11), array.set(ens,11, en12), array.set(ens,12, en13), array.set(ens,13, en14), array.set(ens,14, en15)
    array.set(ens,15, en16), array.set(ens,16, en17), array.set(ens,17, en18), array.set(ens,18, en19), array.set(ens,19, en20)
    array.set(ens,20, en21), array.set(ens,21, en22), array.set(ens,22, en23)
    array.set(ens,23, en24), array.set(ens,24, en25), array.set(ens,25, en26)

    // offsets
    array.set(offs, 0, p1),  array.set(offs, 1, p2),  array.set(offs, 2, p3),  array.set(offs, 3, p4),  array.set(offs, 4, p5)
    array.set(offs, 5, p6),  array.set(offs, 6, p7),  array.set(offs, 7, p8),  array.set(offs, 8, p9),  array.set(offs, 9, p10)
    array.set(offs,10, p11), array.set(offs,11, p12), array.set(offs,12, p13), array.set(offs,13, p14), array.set(offs,14, p15)
    array.set(offs,15, p16), array.set(offs,16, p17), array.set(offs,17, p18), array.set(offs,18, p19), array.set(offs,19, p20)
    array.set(offs,20, p21), array.set(offs,21, p22), array.set(offs,22, p23)
    array.set(offs,23, p24), array.set(offs,24, p25), array.set(offs,25, p26)

    // colors
    array.set(cols, 0, c1),  array.set(cols, 1, c2),  array.set(cols, 2, c3),  array.set(cols, 3, c4),  array.set(cols, 4, c5)
    array.set(cols, 5, c6),  array.set(cols, 6, c7),  array.set(cols, 7, c8),  array.set(cols, 8, c9),  array.set(cols, 9, c10)
    array.set(cols,10, c11), array.set(cols,11, c12), array.set(cols,12, c13), array.set(cols,13, c14), array.set(cols,14, c15)
    array.set(cols,15, c16), array.set(cols,16, c17), array.set(cols,17, c18), array.set(cols,18, c19), array.set(cols,19, c20)
    array.set(cols,20, c21), array.set(cols,21, c22), array.set(cols,22, c23)
    array.set(cols,23, c24), array.set(cols,24, c25), array.set(cols,25, c26)

    // label text (Points 1–23 show numbers; 24–26 show explicit names)
    for i = 0 to N - 1
        array.set(txts, i, str.tostring(i + 1))
    array.set(txts, 23, "INV A")
    array.set(txts, 24, "INV B")
    array.set(txts, 25, "OPT C")


//====================
// Opacity helper for past cycles
//====================
f_pastOpacity(int age, int total) =>
    int op = pastNewestOp
    if total <= 1
        op := pastNewestOp
    else
        float t = (age - 1.0) / (total - 1.0)
        op := int(math.round(pastNewestOp + (pastOldestOp - pastNewestOp) * t))
    op


//====================
// Draw a single cycle instance
//====================
f_drawCycle(int startBar, int opacity, bool drawBoxes, bool drawLabs, float yPivot, labSize) =>
    for idx = 0 to N - 1
        if array.get(ens, idx)
            int x = startBar + array.get(offs, idx)
            if x >= xMin and x <= xMax
                color baseC = array.get(cols, idx)
                color pc    = color.new(baseC, opacity)

                // Window bands (optional)
                if drawBoxes and showWindow and tolBars > 0
                    box bx = box.new(x - tolBars, high, x + tolBars, low, xloc=xloc.bar_index,
                        bgcolor=color.new(baseC, windowOpacity), border_color=color.new(baseC, 100))
                    array.push(gBoxes, bx)

                // Vertical timing line
                line ln = line.new(x, low, x, high, xloc=xloc.bar_index, extend=extend.both,
                    style=line.style_dotted, width=1, color=pc)
                array.push(gLines, ln)

                // Labels
                if drawLabs
                    color bg = color.new(color.black, 100)
                    if numStyleIn == "Colored Badge"
                        bg := pc

                    color tx = pc
                    if numStyleIn == "Colored Badge"
                        tx := color.white

                    string t = array.get(txts, idx)
                    label lb = label.new(x, yPivot, t, xloc=xloc.bar_index,
                        style=(labelAtTop ? label.style_label_down : label.style_label_up),
                        textcolor=tx, color=bg, size=labSize)
                    array.push(gLabs, lb)


//====================
// Draw (last bar only)
//====================
if barstate.islast
    f_refreshArrays()
    labSize = f_labelSize()
    f_clearAll()

    float basePivot = labelAtTop ? high : low
    float yPivot    = basePivot + (labelAtTop ? labelYOffset : -labelYOffset)

    int wantPastCycles = cycleLen > 0 ? int(math.ceil(barsBackLookback / cycleLen)) : 0
    int pastCyclesEff  = math.min(wantPastCycles, 25)  // stable cap

    // Past
    if showPast and pastCyclesEff > 0
        for age = pastCyclesEff to 1
            int op = f_pastOpacity(age, pastCyclesEff)
            int startPast = curStart - (age * cycleLen)
            bool drawBoxes = not pastLinesOnly
            bool drawLabs  = showNumsPast and (age <= pastNumsCycles)
            f_drawCycle(startPast, op, drawBoxes, drawLabs, yPivot, labSize)

    // Current
    if showCurrent
        f_drawCycle(curStart, curFutOpacity, true, showNumsCurrent, yPivot, labSize)

    // Future
    if showFuture and futureCycles > 0
        for fwd = 1 to futureCycles
            int startFut = curStart + (fwd * cycleLen)
            bool drawLabs = showNumsFuture and (fwd <= futNumsCycles)
            f_drawCycle(startFut, curFutOpacity, false, drawLabs, yPivot, labSize)

